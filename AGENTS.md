- Главная парадигма разработки - глубокое понимание принципов работы с Regelum.
- Перед началом разработки, необходимо тщательно изучить Regelum.
- Главный принцип Regelum - практически всё необходимое для разработки пайплайнов должно быть доступно из коробки. Поэтому не нужно изобретать велосипед, а нужно использовать имеющиеся инструменты, в том числе синтаксический сахар.
- Если нет уверенности в том, как именно работает метод, необходимо для начала протестировать его вручную и посмотреть на результаты.
- В коде ЗАПРЕЩЕНО использовать try-except блоки. Необходимо чётко понимать контракт каждого из методов и использовать их максимально корректно.
- Запрещено использовать getattr, а также перебирать варианты ключей словарей и названий методов (см. предыдущий пункт)
- Главная цель - сделать КОРРЕКТНЫЙ код, а не код, который не падает с ошибкой. Если код не падает с ошибкой, но не работает как надо, это тоже ошибка и не считается достижением поставленной задачи.
- Код программ должен быть читаемым, верифицируемым, модульным и минималистичным. Мы должны избегать появления god objects и избыточного количества helper методов.
- При явных пробелах в логике или противоречиях в запросах пользователя, необходимо высказать свои сомнения и задать конкретные вопросы прежде чем приступать к разработке.
- Для каждого пункта технического задания надо сформировать заранее набор ключевых "механик" (например, определённых алгоритмов или математических преобразований или методов из библиотек), на корректность которых мы будем опираться, поэтому прежде чем приступать к разработке этого пункта, необходимо проверить каждую из них на игрушечных коротких примерах, способных явно отвергнуть или подтвердить предпосылки, без которых данная "механика" не сможет работать - фактически, это принцип TDD (Test-Driven Development). Ключевая эвристика для определения "механики" это вопросы "А как это работает? А точно ли я уверен, что это именно так работает? А как это проверить?" или явное выделение этой механики в отдельный метод кода.
- Когда мы пишем тесты, мы должны не просто получить зелёные галочки, а сформировать краевые и общие случаи для тестирования. В случае, если тесты падают, мы должны сначала понять, в чем именно была ошибка - в самих тестах или в "механиках", которые мы тестируем. Если ошибка была в тестах, то просто исправляем тест, но если ошибка была в механике, то сначала надо разобраться, какая ошибка в наших рассуждениях привела к этому и задаться вопросом о том, где ещё в коде мы могли из-за этого ошибиться и увеличить покрытие тестами. Любые тесты должны быть написаны не ради покрытия, а ради реальной проверки краевых случаев, математики и тонких мест.
- НЕ ДОБАВЛЯЙ ВРУЧНУЮ dependencies в pyproject.toml - используй uv add для добавления пакетов в виртуальное окружение либо актуализируй знание о последних версиях пакетов через context7 mcp сервер.

# Стек:

- uv для управления виртуальным окружением: uv add для добавления пакетов в виртуальное окружение, uv run для запуска скриптов в виртуальном окружении. Если ты запускаешь код из sandbox и получаешь ошибку доступа при uv run, то либо запроси у меня права на исполнение либо UV_CACHE_DIR=.uv-cache uv run для запуска скриптов в дальнейшем, если опция запроса привилегий не доступна.
- pytest для написания и запуска тестов
- tyro для написания CLI интерфейсов. ЗАПРЕЩЕНО использовать argparser.
- pyright линтер для статического анализа кода и типизации.

# Оформление кода:

SOLID, DRY (без лишнего усердия - избегаем сильного coupling там, где это не нужно), стараемся избегать side effects и писать максимально верифицируемый и тестируемый код.
Избегаем относительных импортов.
Избегаем магических чисел и строк: константы и глобальные переменные должны быть явно названы и описаны в отдельных модулях или конфигурационных файлах.
Избегаем длинных модулей больше 400 строк. В случае, если модуль становится слишком длинным, нужно предложить разделить его на несколько модулей, проведя рефакторинг (перед этим нужно пробежаться по коду и сформировать план рефакторинга)
Избегаем избыточного Error Handling и недостижимого бранчинга на бесполезные проверки. Эвристика: чем больше в коде проверок тем сильнее это показывает нам, что мы не до конца понимаем логику и/или контракты наших методов и/или данных, а следовательно мы нуждаемся в более глубоком понимании кода и последующем рефакторинге.